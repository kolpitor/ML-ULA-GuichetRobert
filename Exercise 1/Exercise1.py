# -*- coding: utf-8 -*-
"""part1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d1T5ylbsCQyzePScc6C-x-tbf5536RQ4

Définissons Z = (X, Y), où X représente la taille (en centimètres) d'un homme adulte choisi au hasard, modélisée comme une variable aléatoire continue suivant une distribution normale de moyenne μ_X = 175 cm et d'écart-type σ_X = 6 cm. Y représente le poids (en kilogrammes) de cette même personne, modélisée comme une variable aléatoire continue suivant une distribution normale de moyenne μ_Y = 70 kg et d'écart-type σ_Y = 10 kg.

La valeur attendue de Z est :

E[Z] = (E[X], E[Y]) = (μ_X, μ_Y) = (175, 70)

Prélevons n = 1000 points de la distribution jointe de Z et représentons-les dans un nuage de points en 2D :
"""

import numpy as np
import matplotlib.pyplot as plt

# Paramètres des distributions X et Y
mu_X = 175
sigma_X = 6
mu_Y = 70
sigma_Y = 10

# Prélèvement de n points selon la distribution jointe
n = 1000
X_values = np.random.normal(mu_X, sigma_X, size=n)
Y_values = np.random.normal(mu_Y, sigma_Y, size=n)

# Représentation des points prélevés
plt.scatter(X_values, Y_values, alpha=0.5)
plt.xlabel('Taille (cm)')
plt.ylabel('Poids (kg)')
plt.show()

"""# Exercice 1

Le nuage de points montre une forme elliptique avec une densité plus élevée autour de (175, 70) et une densité plus faible vers les bords de l'ellipse.

Enfin, calculons la moyenne empirique des premiers n échantillons en fonction du nombre d'échantillons n et vérifions qu'elle converge vers la valeur attendue. Nous pouvons le faire en calculant la moyenne des k premiers échantillons pour chaque k de 1 à n, puis en traçant la distance euclidienne entre la moyenne des échantillons et la valeur attendue en fonction de k :
"""

# Compute the empirical averages as a function of n
sample_means = np.zeros((n, 2))
for k in range(1, n+1):
    sample_means[k-1] = np.mean(np.column_stack((X_values[:k], Y_values[:k])), axis=0)

# Compute the Euclidean distance between the sample mean and the expected value for each k
distances = np.linalg.norm(sample_means - np.array([mu_X, mu_Y]), axis=1)

# Plot the distances as a function of k
plt.plot(range(1, n+1), distances)
plt.xlabel('Number of samples (k)')
plt.ylabel('Distance to expected value')
plt.show()

"""Le graphique montre que la distance à la valeur attendue diminue à mesure que le nombre d'échantillons augmente, et se rapproche finalement de zéro lorsque k approche de n. Cela confirme que la moyenne empirique converge vers la valeur attendue lorsque le nombre d'échantillons augmente."""